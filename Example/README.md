# Example

Let us consider a 5 Degrees of Freedom (DOF) shear type frame with lumped mass m
= 25.91 [N-s\^2/mm] at each floor, and same storey stiffness k = 10000 [N/mm] to
all stories. Solving the eigenvalue problem gives the natural frequencies of the
system:

![title](Images/image001.png)

And the (unity normalised) mode shapes:

![title](Images/image003.png)

Assuming Rayleigh damping (C=aM+bK) with a=0.2 and b=0.001 we get the following
damping:

![title](Images/image005.png)

Synthetic signals, corresponding to the acceleration time history at each floor,
are then generated by integration using Newmark’s method (constant
acceleration). All the 5 DOF are excited by a Gaussian white noise input, then
the results from each channel are polluted with a noise source with SN=10%.

# Preliminary operations

First of all, we need to import all the necessary modules, and the data as an
array.
Be careful to the parameters “header” and “sep” in the pd.read\_csv function,
to correctly read and import the data file.

```python

# Import modules

import numpy as np
import pandas as pd
import seaborn as sns
from scipy import signal
import matplotlib.pyplot as plt
import pyOMA as oma

# ======== PRE-PROCESSING =====================================================
# To open a .txt file create a variable containing the path to the file
_file = r"C:<Path to the txt file>\Ex_file.txt" # Path to the txt file

# open the file with pandas and create a dataframe
# N.B. whatchout for header, separator and remove time column if present
data = pd.read_csv(_file, header=0, sep="\t", index_col=False) 
data = data.to_numpy()

# to retrieve the example data 
data, (fex, FI_ex, xi_ex) = oma.Exdata()

```

We need then to provide the sampling frequency. We can also detrend and/or
decimate the signal using standard scypy.signal functions:

```python

# Sampling frequency
fs = 100 # [Hz] Sampling Frequency

# Using SciPy's signal module we can pre-process our data e.g. performing
# decimation, trend removal and filtering. 
# Detrend and decimate
data = signal.detrend(data, axis=0) # Trend rmoval
q = 5 # Decimation factor
data = signal.decimate(data,  q, ftype='fir', axis=0) # Decimation
fs = fs/q # [Hz] Decimated sampling frequency

# Filter
_b, _a = signal.butter(12, (0.3,6.5), fs=fs, btype='bandpass')
filtdata = signal.filtfilt(_b, _a, data,axis=0) # filtered data

```

We are now ready to execute the identifications algorithms onto the data.

# Identification – Frequency Domain

We start by running OMA.FDDsvp to perform the Frequency Domain Decomposition
(FDD) algorithm, which returns a plot of the Singular Values (SV) of the Power
Spectral Density (PSD) matrix, and a dictionary that contains the results that
will be processed later to extract the modal properties.

```python
# Run FDD

FDD = oma.FDDsvp(data,  fs)
```

![title](Images/image007.png)

The peaks in the plot are an estimate to the natural frequencies of the system.
To help the identification of the peaks the mplcursors.cursor() function is used
in the interactive plot.

```python

# Define list/array with the peaks identified from the plot

FreQ = [0.89, 2.6, 4.1, 5.27, 6] # identified peaks

```

We can now run OMA.FDDmodEX and/or OMA.EFDDmodEX to extract the modal
information according to the “FDD method” and/or the “Enhanced-FDD (EFDD)
method” respectively. All “modEX” functions return a dictionary that contains
the results of the identification in terms of modal properties. The OMA.FDDmodEX
function will only extract the natural frequency and the mode shape, according
to the original FDD algorithm as presented in (Brincker & ventura). The
EFDDmodEX function has two methods that can be selected. Method ‘EFDD’ extracts
the modal properties (frequencies, mode shapes, damping) according to the EFDD
algorithm as presented in (brinker & ventura). The method ‘FSDD’ instead extract
the modal properties (frequencies, mode shapes, damping) according to the
Frequency-Spatial Domain Decomposition (FSDD) method (zhang). The latter method
isolates the modal coordinates by modal filtering and provides enhanced output
PSD estimates, which in return yield better autocorrelation functions. The
required parameters by the functions are: “FreQ” = the list of peaks previously
identified in the SV plot; “Results” = the dictionary of results returned by
OMA.FDDsvp.

```python

# Extract the modal properties 
Res_FDD = oma.FDDmodEX(FreQ, FDD[1])
Res_EFDD = oma.EFDDmodEX(FreQ, FDD[1], method='EFDD')
Res_FSDD = oma.EFDDmodEX(FreQ, FDD[1], method='FSDD', npmax = 35, MAClim=0.95, plot=True)
```

We can now see the results of the identification by inspecting the results
dictionaries:

```python

Res_FDD[‘Frequencies’] = [0.89, 2.60, 4.06, 5.23, 5.91]

Res_EFDD[‘Frequencies’] = [0.88, 2.58, 4.07, 5.19, 5.94]

Res_FSDD[‘Frequencies’] = [0.89, 2.59, 4.07, 5.21, 5.91]

Res_EFDD[‘Damping’] = [2.76%, 2.18%, 2.20%, 2.42%, 2.45%]

Res_FSDD[‘Damping’] = [2.47%, 1.64%, 1.72%, 2.05%, 2.22%]

Res_FDD[‘Mode Shapes’] =

| 0.2755 | 0.7494  | 1       | 0.9267  | 0.4923  |
|--------|---------|---------|---------|---------|
| 0.5172 | 1       | 0.2914  | -0.7842 | -0.8666 |
| 0.7718 | 0.5274  | -0.9324 | -0.2790 | 1       |
| 0.9230 | -0.2883 | -0.5510 | 1       | -0.7430 |
| 1      | -0.9139 | 0.7614  | -0.5425 | 0.2983  |

Res_EFDD[‘Mode Shapes’] =

| 0.2682 | 0.7544  | 1       | 0.9141  | 0.4985  |
|--------|---------|---------|---------|---------|
| 0.5370 | 1       | 0.2835  | -0.7589 | -0.8705 |
| 0.7673 | 0.5287  | -0.8967 | -0.2893 | 1       |
| 0.9012 | -0.2733 | -0.5418 | 1       | -0.7522 |
| 1      | -0.8631 | 0.7548  | -0.5450 | 0.2845  |

Res_FSDD[‘Mode Shapes’] =

| 0.2770 | 0.7559  | 1       | 0.9254  | 0.5203  |
|--------|---------|---------|---------|---------|
| 0.5371 | 1       | 0.2886  | -0.7632 | -0.8968 |
| 0.7680 | 0.5384  | -0.9104 | -0.2878 | 1       |
| 0.9206 | -0.2775 | -0.5464 | 1       | -0.7594 |
| 1      | -0.9017 | 0.7630  | -0.5441 | 0.2861  |

```

The EFDDmodEX function will also return one plot for each element of FreQ,
showing: the identified Single DOF bell function associated to a dominating
frequency, the autocorrelation function of the SDOF bell function, the portion
of the autocorrelation function used to estimate the modal properties, and
finally the fit on the selected portion of data.

![title](Images/image009.png)![title](Images/image011.png)


# Identification – Time Domain

To perform the identification in the time domain we have two option. The
functions OMA.SSIcovStaDiag and OMA.SSIdatStaDiag will run the “Covariance
driven Stochastic Sub-space Identification” algorithm and the “Data driven
Stochastic Sub-space Identification” algorithm , respectively (see Peeters, Van
come cazzo si chiama, Rainieri e Fabbrocino). Both functions will return a
Stabilization Diagram plot, where the stable poles of the system, corresponding
to the natural frequencies, will eventually align, for increasing model order.
The required parameters by the functions are: “data” = the (ndat x nch) array of
measurements; “fs” = the sampling frequency; “br” = the number of block rows.

```python
# Run SSI

br = 5

SSIcov= OMA.SSIcovStaDiag(data fs, br)

SSIdat = OMA.SSIdatStaDiag(data, fs, br)

```

![title](Images/image013.png)![title](Images/image015.png)


We may want to increase the number of block rows, but keep a certain maximum
model order, then we can use the parameter “ordmax”, which by default is kept to
the maximum allwable model order, ordmax= nch x br, where nch is the number of
channels.

```python
# Run SSI

br = 10

SSIcov= OMA.SSIcovStaDiag(data, fs, br, ordmax=25)

SSIdat = OMA.SSIdatStaDiag(data, fs, br, ordmax=25)

```

![title](Images/image017.png)![title](Images/image019.png)


The aligned green dots are the stable poles of the system, which are an estimate
of the natural frequencies. To help the identification of the stable poles the
mplcursors.cursor() function is used in the interactive plot.

```python
# Define list/array with the aligned poles identified from the plot

FreQ = [0.89, 2.59, 4.07, 5.22, 5.92] # identified poles
```

We can now run the function OMA.SSIModEX, that will return a dictionary that
contains the results of the identification in terms of modal properties (natural
frequencies, mode shapes, damping). The required parameters by the functions
are: “FreQ” = the list of stable poles previously identified in the
Stabilization Diagram plot; “Results” = the dictionary of results returned by
OMA.SSIcovStaDiag and/or OMA.SSIdatStaDiag.

```python
# Extract the modal properties

Res_SSIcov = OMA.SSIModEX(FreQ, SSIcov[1])

Res_SSIdat= OMA.SSIModEX(FreQ, SSIdat[1])

We can now see the results of the identification by inspecting the results
dictionaries:

Res_SSIcov[‘Frequencies’] = [0.89, 2.59, 4.07, 5.22, 5.93]

Res_SSIdat[‘Frequencies’] = [0.89, 2.59, 4.07, 5.22, 5.93]

Res_SSIcov[‘Damping’] = [2.26%, 1.46%, 1.69%, 1.91%, 2.12%]

Res_SSIdat[‘Damping’] = [2.38%, 1.45%, 1.72%, 1.94%, 2.13%]

Res_SSIcov[‘Mode Shapes’] =

| 0.2786 | 0.7548  | 1       | 0.9372  | 0.5385  |
|--------|---------|---------|---------|---------|
| 0.5483 | 1       | 0.2908  | -0.7708 | -0.9165 |
| 0.7799 | 0.5405  | -0.9177 | -0.2868 | 1       |
| 0.9297 | -0.2779 | -0.5520 | 1       | -0.7571 |
| 1      | -0.9148 | 0.7708  | -0.5468 | 0.2852  |

Res_SSIdat[‘Mode Shapes’] =

| 0.2771 | 0.7595  | 1       | 0.9255  | 0.5385  |
|--------|---------|---------|---------|---------|
| 0.5398 | 1       | 0.2902  | -0.7657 | -0.9156 |
| 0.7671 | 0.5413  | -0.9200 | -0.2851 | 1       |
| 0.9049 | -0.2785 | -0.5497 | 1       | -0.7630 |
| 1      | -0.9204 | 0.7671  | -0.5432 | 0.2857  |
```