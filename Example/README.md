# Example

Let us consider a 5 Degrees of Freedom (DOF) shear type frame with lumped mass m
= 25.91 [N-s\^2/mm] at each floor, and same storey stiffness k = 10000 [N/mm] to
all stories. Solving the eigenvalue problem gives the natural frequencies of the
system:

![title](Images/image001.png)

And the (unity normalised) mode shapes:

![title](Images/image003.png)

Assuming Rayleigh damping (C=aM+bK) with a=0.2 and b=0.001 we get the following
damping:

![title](Images/image005.png)

Synthetic signals, corresponding to the acceleration time history at each floor,
are then generated by integration using Newmark’s method (constant
acceleration). All the 5 DOF are excited by a Gaussian white noise input, then
the results from each channel are polluted with a noise source with SN=10%.

# Preliminary operations

First of all, we need to import all the necessary modules, and the data as an
array.
Be careful to the parameters “header” and “sep” in the pd.read\_csv function,
to correctly read and import the data file.

```python

# Import modules

import numpy as np
import pandas as pd
import seaborn as sns
from scipy import signal
import matplotlib.pyplot as plt
import pyOMA as oma

# ======== PRE-PROCESSING =====================================================
# To open a .txt file create a variable containing the path to the file
_file = r"C:<Path to the txt file>\Ex_file.txt" # Path to the txt file

# open the file with pandas and create a dataframe
# N.B. whatchout for header, separator and remove time column if present
data = pd.read_csv(_file, header=0, sep="\t", index_col=False) 
data = data.to_numpy()

# to retrieve the example data 
data, (fex, FI_ex, xi_ex) = oma.Exdata()

```

We need then to provide the sampling frequency. We can also detrend and/or
decimate the signal using standard scypy.signal functions:

```python

# Sampling frequency
fs = 100 # [Hz] Sampling Frequency

# Using SciPy's signal module we can pre-process our data e.g. performing
# decimation, trend removal and filtering. 
# Detrend and decimate
data = signal.detrend(data, axis=0) # Trend rmoval
q = 5 # Decimation factor
data = signal.decimate(data,  q, ftype='fir', axis=0) # Decimation
fs = fs/q # [Hz] Decimated sampling frequency

# Filter
_b, _a = signal.butter(12, (0.3,6.5), fs=fs, btype='bandpass')
filtdata = signal.filtfilt(_b, _a, data,axis=0) # filtered data

```

We are now ready to execute the identifications algorithms onto the data.

# Identification – Frequency Domain

We start by running OMA.FDDsvp to perform the Frequency Domain Decomposition
(FDD) algorithm, which returns a plot of the Singular Values (SV) of the Power
Spectral Density (PSD) matrix, and a dictionary that contains the results that
will be processed later to extract the modal properties.

```python
# Run FDD

FDD = oma.FDDsvp(data,  fs)
```

![title](Images/image007.png)

The peaks in the plot are an estimate to the natural frequencies of the system.
To help the identification of the peaks the mplcursors.cursor() function is used
in the interactive plot.

```python

# Define list/array with the peaks identified from the plot

FreQ = [0.89, 2.6, 4.1, 5.27, 6] # identified peaks

```

We can now run oma.FDDmodEX and/or oma.EFDDmodEX to extract the modal
information according to the “FDD method” and/or the “Enhanced-FDD (EFDD)
method” respectively. All “modEX” functions return a dictionary that contains
the results of the identification in terms of modal properties. The oma.FDDmodEX
function will only extract the natural frequency and the mode shape, according
to the original FDD algorithm as presented in (Brincker & ventura). The
EFDDmodEX function has two methods that can be selected. Method ‘EFDD’ extracts
the modal properties (frequencies, mode shapes, damping) according to the EFDD
algorithm as presented in (brinker & ventura). The method ‘FSDD’ instead extract
the modal properties (frequencies, mode shapes, damping) according to the
Frequency-Spatial Domain Decomposition (FSDD) method (zhang). The latter method
isolates the modal coordinates by modal filtering and provides enhanced output
PSD estimates, which in return yield better autocorrelation functions. The
required parameters by the functions are: “FreQ” = the list of peaks previously
identified in the SV plot; “Results” = the dictionary of results returned by
oma.FDDsvp.

```python

# Extract the modal properties 
Res_FDD = oma.FDDmodEX(FreQ, FDD[1])
Res_EFDD = oma.EFDDmodEX(FreQ, FDD[1], method='EFDD')
Res_FSDD = oma.EFDDmodEX(FreQ, FDD[1], method='FSDD', npmax = 35, MAClim=0.95, plot=True)

# Run SSI
br = 15
SSIcov= oma.SSIcovStaDiag(data, fs, br)
SSIdat = oma.SSIdatStaDiag(data, fs, br, ordmax=60, lim=(0.01, 0.05, 0.02, 0.1)) 

# Extract the modal properties
Res_SSIcov = oma.SSIModEX(FreQ, SSIcov[1])
Res_SSIdat= oma.SSIModEX(FreQ, SSIdat[1])
```

We can now see the results of the identification by inspecting the results
dictionaries:

```python

Res_FDD[‘Frequencies’] = [0.89, 2.60, 4.06, 5.23, 5.91]

Res_EFDD[‘Frequencies’] = [0.88, 2.58, 4.07, 5.19, 5.94]

Res_FSDD[‘Frequencies’] = [0.89, 2.59, 4.07, 5.21, 5.91]

Res_EFDD[‘Damping’] = [2.76%, 2.18%, 2.20%, 2.42%, 2.45%]

Res_FSDD[‘Damping’] = [2.47%, 1.64%, 1.72%, 2.05%, 2.22%]

Res_FDD[‘Mode Shapes’] =

| 0.2755 | 0.7494  | 1       | 0.9267  | 0.4923  |
|--------|---------|---------|---------|---------|
| 0.5172 | 1       | 0.2914  | -0.7842 | -0.8666 |
| 0.7718 | 0.5274  | -0.9324 | -0.2790 | 1       |
| 0.9230 | -0.2883 | -0.5510 | 1       | -0.7430 |
| 1      | -0.9139 | 0.7614  | -0.5425 | 0.2983  |

Res_EFDD[‘Mode Shapes’] =

| 0.2682 | 0.7544  | 1       | 0.9141  | 0.4985  |
|--------|---------|---------|---------|---------|
| 0.5370 | 1       | 0.2835  | -0.7589 | -0.8705 |
| 0.7673 | 0.5287  | -0.8967 | -0.2893 | 1       |
| 0.9012 | -0.2733 | -0.5418 | 1       | -0.7522 |
| 1      | -0.8631 | 0.7548  | -0.5450 | 0.2845  |

Res_FSDD[‘Mode Shapes’] =

| 0.2770 | 0.7559  | 1       | 0.9254  | 0.5203  |
|--------|---------|---------|---------|---------|
| 0.5371 | 1       | 0.2886  | -0.7632 | -0.8968 |
| 0.7680 | 0.5384  | -0.9104 | -0.2878 | 1       |
| 0.9206 | -0.2775 | -0.5464 | 1       | -0.7594 |
| 1      | -0.9017 | 0.7630  | -0.5441 | 0.2861  |

```

Now, let's have some plot of our data.

```python

# =============================================================================
# Make some plots
# =============================================================================
MS_EFDD = Res_EFDD['Mode Shapes']
MS_FSDD = Res_FSDD['Mode Shapes']
MS_SSIcov = Res_SSIcov['Mode Shapes']
MS_SSIdat = Res_SSIdat['Mode Shapes']
_nch = data.shape[1]

MAC = np.reshape(
        [oma.MaC(FI_ex[:,l], MS_FSDD[:,k]).real for k in range(_nch) for l in range(_nch)], # (_nch*_nch) list of MAC values 
        (_nch, _nch)) # new (real) shape (_nch x _nch) of the MAC matrix

autoMAC = np.reshape(
        [oma.MaC(MS_SSIcov[:,l], MS_SSIdat[:,k]).real for k in range(_nch) for l in range(_nch)], # (_nch*_nch) list of MAC values 
        (_nch,_nch)) # new (real) shape (_nch x _nch) of the MAC matrix

col = ["mode I", "mode II", "mode III", "mode IV", "mode V"]

MAC = pd.DataFrame(MAC, columns=col, index=col)
autoMAC = pd.DataFrame(autoMAC, columns=col, index=col)

fig, ax = plt.subplots()
sns.heatmap(MAC,cmap="jet",ax=ax,annot=True, fmt='.3f',)
fig.tight_layout()
plt.show()

fig, ax1 = plt.subplots()
sns.heatmap(autoMAC,cmap="jet", ax=ax1, annot=True, fmt='.3f',)
fig.tight_layout()
plt.show()

```

![title](Images/image009.png)![title](Images/image011.png)

